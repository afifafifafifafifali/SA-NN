// SA-NN Interference Header Generated by SA-NN ( SPELLING MISTAKE AINT BEING REPAIRED)
#include <stdint.h>
#include <avr/pgmspace.h>
#ifndef SA_NN_MODEL_H
#define SA_NN_MODEL_H

#define L0_IN 4
#define L0_OUT 8
#define L1_IN 8
#define L1_OUT 12
#define L2_IN 12
#define L2_OUT 8
#define L3_IN 8
#define L3_OUT 3

const int8_t SIGN_L0[8][4] PROGMEM = {
  {-1, 1, -1, 1},
  {1, 1, -1, 1},
  {-1, -1, 1, 1},
  {1, -1, 1, 1},
  {-1, -1, -1, -1},
  {1, -1, 1, -1},
  {-1, 1, 1, -1},
  {-1, -1, 1, 1}
};
const int8_t SIGN_L1[12][8] PROGMEM = {
  {1, 1, -1, -1, -1, -1, 1, -1},
  {1, -1, 1, 1, -1, 1, -1, -1},
  {1, -1, 1, 1, 1, 1, 1, 1},
  {1, -1, 1, -1, 1, 1, -1, 1},
  {-1, 1, 1, 1, 1, -1, -1, 1},
  {1, 1, 1, 1, 1, 1, -1, 1},
  {-1, -1, 1, -1, -1, -1, -1, 1},
  {-1, 1, 1, -1, -1, 1, 1, 1},
  {-1, -1, 1, -1, 1, 1, -1, -1},
  {1, -1, 1, 1, -1, 1, -1, 1},
  {1, -1, -1, 1, 1, -1, 1, 1},
  {-1, 1, 1, 1, -1, -1, 1, 1}
};
const int8_t SIGN_L2[8][12] PROGMEM = {
  {-1, -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, -1},
  {-1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1},
  {1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1},
  {1, -1, 1, 1, -1, 1, 1, 1, -1, 1, -1, 1},
  {1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1},
  {1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1},
  {1, -1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1},
  {1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, 1}
};
const int8_t SIGN_L3[3][8] PROGMEM = {
  {-1, 1, 1, -1, 1, 1, 1, -1},
  {1, 1, 1, 1, 1, -1, 1, -1},
  {1, 1, -1, 1, -1, 1, -1, 1}
};

const uint8_t SHIFT_L0[8][4] PROGMEM = {
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0},
  {0, 0, 0, 0}
};
const uint8_t SHIFT_L1[12][8] PROGMEM = {
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0}
};
const uint8_t SHIFT_L2[8][12] PROGMEM = {
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};
const uint8_t SHIFT_L3[3][8] PROGMEM = {
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0, 0}
};

const int16_t BIAS_L0[8] PROGMEM = { 0, 0, 0, 0, 0, 0, 0, 0 };
const int16_t BIAS_L1[12] PROGMEM = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
const int16_t BIAS_L2[8] PROGMEM = { 0, 0, 0, 0, 0, 0, 0, 0 };
const int16_t BIAS_L3[3] PROGMEM = { 0, 0, 0 };

#define MAX_VAL 32764

int16_t relu(int16_t x){return x>0?x:0;}

void interfere(const int8_t* input,int16_t* output){
  int16_t layer_0[L0_OUT];
  int16_t layer_1[L1_OUT];
  int16_t layer_2[L2_OUT];
  int16_t layer_3[L3_OUT];
  for(int j=0;j<L0_OUT;j++){
    int32_t sum=pgm_read_word(&(BIAS_L0[j]));
    for(int k=0;k<L0_IN;k++){
      int16_t val=input[k];
      sum+=(int8_t)pgm_read_byte(&(SIGN_L0[j][k]))*(val<<(uint8_t)pgm_read_byte(&(SHIFT_L0[j][k])));
    }
    sum=relu((int16_t)sum);
    if(sum<0)sum=0;else if(sum>MAX_VAL)sum=MAX_VAL;
    layer_0[j]=(int16_t)sum;
  }
  for(int j=0;j<L1_OUT;j++){
    int32_t sum=pgm_read_word(&(BIAS_L1[j]));
    for(int k=0;k<L1_IN;k++){
      int16_t val=layer_0[k];
      sum+=(int8_t)pgm_read_byte(&(SIGN_L1[j][k]))*(val<<(uint8_t)pgm_read_byte(&(SHIFT_L1[j][k])));
    }
    sum=relu((int16_t)sum);
    if(sum<0)sum=0;else if(sum>MAX_VAL)sum=MAX_VAL;
    layer_1[j]=(int16_t)sum;
  }
  for(int j=0;j<L2_OUT;j++){
    int32_t sum=pgm_read_word(&(BIAS_L2[j]));
    for(int k=0;k<L2_IN;k++){
      int16_t val=layer_1[k];
      sum+=(int8_t)pgm_read_byte(&(SIGN_L2[j][k]))*(val<<(uint8_t)pgm_read_byte(&(SHIFT_L2[j][k])));
    }
    sum=relu((int16_t)sum);
    if(sum<0)sum=0;else if(sum>MAX_VAL)sum=MAX_VAL;
    layer_2[j]=(int16_t)sum;
  }
  for(int j=0;j<L3_OUT;j++){
    int32_t sum=pgm_read_word(&(BIAS_L3[j]));
    for(int k=0;k<L3_IN;k++){
      int16_t val=layer_2[k];
      sum+=(int8_t)pgm_read_byte(&(SIGN_L3[j][k]))*(val<<(uint8_t)pgm_read_byte(&(SHIFT_L3[j][k])));
    }
    if(sum<0)sum=0;else if(sum>MAX_VAL)sum=MAX_VAL;
    output[j]=(int16_t)sum;
  }
}
#endif // SA_NN_MODEL_H